{"version":3,"sources":["../../../src/server/request/params.ts"],"sourcesContent":["import type { WorkStore } from '../app-render/work-async-storage.external'\nimport type { FallbackRouteParams } from './fallback-params'\n\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\nimport {\n  abortAndThrowOnSynchronousRequestDataAccess,\n  throwToInterruptStaticGeneration,\n  postponeWithTracking,\n} from '../app-render/dynamic-rendering'\n\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStorePPR,\n  type PrerenderStoreLegacy,\n  type PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport {\n  makeResolvedReactPromise,\n  describeStringPropertyAccess,\n  wellKnownProperties,\n} from './utils'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-loger'\n\nexport type Params = Record<string, string | Array<string> | undefined>\n\n/**\n * In this version of Next.js the `params` prop passed to Layouts, Pages, and other Segments is a Promise.\n * However to facilitate migration to this new Promise type you can currently still access params directly on the Promise instance passed to these Segments.\n * The `UnsafeUnwrappedParams` type is available if you need to temporarily access the underlying params without first awaiting or `use`ing the Promise.\n *\n * In a future version of Next.js the `params` prop will be a plain Promise and this type will be removed.\n *\n * Typically instances of `params` can be updated automatically to be treated as a Promise by a codemod published alongside this Next.js version however if you\n * have not yet run the codemod of the codemod cannot detect certain instances of `params` usage you should first try to refactor your code to await `params`.\n *\n * If refactoring is not possible but you still want to be able to access params directly without typescript errors you can cast the params Promise to this type\n *\n * ```tsx\n * type Props = { params: Promise<{ id: string }>}\n *\n * export default async function Layout(props: Props) {\n *  const directParams = (props.params as unknown as UnsafeUnwrappedParams<typeof props.params>)\n *  return ...\n * }\n * ```\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedParams<P> =\n  P extends Promise<infer U> ? Omit<U, 'then' | 'status' | 'value'> : never\n\nexport function createPrerenderParamsFromClient(\n  underlyingParams: Params,\n  workStore: WorkStore\n) {\n  return createPrerenderParams(underlyingParams, workStore)\n}\n\nexport function createRenderParamsFromClient(\n  underlyingParams: Params,\n  workStore: WorkStore\n) {\n  return createRenderParams(underlyingParams, workStore)\n}\n\n// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component\nexport type CreateServerParamsForMetadata = typeof createServerParamsForMetadata\nexport const createServerParamsForMetadata = createServerParamsForServerSegment\n\n// routes always runs in RSC context so it is equivalent to a Server Page Component\nexport function createServerParamsForRoute(\n  underlyingParams: Params,\n  workStore: WorkStore\n) {\n  if (workStore.isStaticGeneration) {\n    return createPrerenderParams(underlyingParams, workStore)\n  } else {\n    return createRenderParams(underlyingParams, workStore)\n  }\n}\n\nexport function createServerParamsForServerSegment(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  if (workStore.isStaticGeneration) {\n    return createPrerenderParams(underlyingParams, workStore)\n  } else {\n    return createRenderParams(underlyingParams, workStore)\n  }\n}\n\nexport function createPrerenderParamsForClientSegment(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  if (prerenderStore && prerenderStore.type === 'prerender') {\n    const fallbackParams = workStore.fallbackRouteParams\n    if (fallbackParams) {\n      for (let key in underlyingParams) {\n        if (fallbackParams.has(key)) {\n          // This params object has one of more fallback params so we need to consider\n          // the awaiting of this params object \"dynamic\". Since we are in dynamicIO mode\n          // we encode this as a promise that never resolves\n          return makeHangingPromise(prerenderStore.renderSignal, '`params`')\n        }\n      }\n    }\n  }\n  // We're prerendering in a mode that does not abort. We resolve the promise without\n  // any tracking because we're just transporting a value from server to client where the tracking\n  // will be applied.\n  return makeResolvedReactPromise(underlyingParams)\n}\n\nfunction createPrerenderParams(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const fallbackParams = workStore.fallbackRouteParams\n  if (fallbackParams) {\n    let hasSomeFallbackParams = false\n    for (const key in underlyingParams) {\n      if (fallbackParams.has(key)) {\n        hasSomeFallbackParams = true\n        break\n      }\n    }\n\n    if (hasSomeFallbackParams) {\n      // params need to be treated as dynamic because we have at least one fallback param\n      const workUnitStore = workUnitAsyncStorage.getStore()\n      if (workUnitStore) {\n        if (workUnitStore.type === 'prerender') {\n          // We are in a dynamicIO (PPR or otherwise) prerender\n          return makeAbortingExoticParams(\n            underlyingParams,\n            workStore.route,\n            workUnitStore\n          )\n        } else if (\n          workUnitStore.type === 'prerender-legacy' ||\n          workUnitStore.type === 'prerender-ppr'\n        )\n          // We aren't in a dynamicIO prerender but we do have fallback params at this\n          // level so we need to make an erroring exotic params object which will postpone\n          // if you access the fallback params\n          return makeErroringExoticParams(\n            underlyingParams,\n            fallbackParams,\n            workStore,\n            workUnitStore\n          )\n      }\n      throw new InvariantError(\n        'createPrerenderParams called without a prerenderStore in scope. This is a bug in Next.js'\n      )\n    }\n  }\n\n  // We don't have any fallback params so we have an entirely static safe params object\n  return makeUntrackedExoticParams(underlyingParams)\n}\n\nfunction createRenderParams(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  if (process.env.NODE_ENV === 'development' && !workStore.isPrefetchRequest) {\n    return makeDynamicallyTrackedExoticParamsWithDevWarnings(\n      underlyingParams,\n      workStore\n    )\n  } else {\n    return makeUntrackedExoticParams(underlyingParams)\n  }\n}\n\ninterface CacheLifetime {}\nconst CachedParams = new WeakMap<CacheLifetime, Promise<Params>>()\n\nfunction makeAbortingExoticParams(\n  underlyingParams: Params,\n  route: string,\n  prerenderStore: PrerenderStoreModern\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const promise = makeHangingPromise<Params>(\n    prerenderStore.renderSignal,\n    '`params`'\n  )\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      Object.defineProperty(promise, prop, {\n        get() {\n          const expression = describeStringPropertyAccess('params', prop)\n          const error = new Error(\n            `Route \"${route}\" used ${expression}. \\`params\\` is now a Promise and should be \\`awaited\\` before accessing param values. See more info here: https://nextjs.org/docs/messages/next-prerender-sync-params`\n          )\n          abortAndThrowOnSynchronousRequestDataAccess(\n            route,\n            expression,\n            error,\n            prerenderStore\n          )\n        },\n        set(newValue) {\n          Object.defineProperty(promise, prop, {\n            value: newValue,\n            writable: true,\n            enumerable: true,\n          })\n        },\n        enumerable: true,\n        configurable: true,\n      })\n    }\n  })\n\n  return promise\n}\n\nfunction makeErroringExoticParams(\n  underlyingParams: Params,\n  fallbackParams: FallbackRouteParams,\n  workStore: WorkStore,\n  prerenderStore: PrerenderStorePPR | PrerenderStoreLegacy\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const augmentedUnderlying = { ...underlyingParams }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(augmentedUnderlying)\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      if (fallbackParams.has(prop)) {\n        Object.defineProperty(augmentedUnderlying, prop, {\n          get() {\n            const expression = describeStringPropertyAccess('params', prop)\n            // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n            // for params is only dynamic when we're generating a fallback shell\n            // and even when `dynamic = \"error\"` we still support generating dynamic\n            // fallback shells\n            // TODO remove this comment when dynamicIO is the default since there\n            // will be no `dynamic = \"error\"`\n            if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no dynamicIO)\n              postponeWithTracking(\n                workStore.route,\n                expression,\n                prerenderStore.dynamicTracking\n              )\n            } else {\n              // Legacy Prerender\n              throwToInterruptStaticGeneration(\n                expression,\n                workStore,\n                prerenderStore\n              )\n            }\n          },\n          enumerable: true,\n        })\n        Object.defineProperty(promise, prop, {\n          get() {\n            const expression = describeStringPropertyAccess('params', prop)\n            // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n            // for params is only dynamic when we're generating a fallback shell\n            // and even when `dynamic = \"error\"` we still support generating dynamic\n            // fallback shells\n            // TODO remove this comment when dynamicIO is the default since there\n            // will be no `dynamic = \"error\"`\n            if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no dynamicIO)\n              postponeWithTracking(\n                workStore.route,\n                expression,\n                prerenderStore.dynamicTracking\n              )\n            } else {\n              // Legacy Prerender\n              throwToInterruptStaticGeneration(\n                expression,\n                workStore,\n                prerenderStore\n              )\n            }\n          },\n          set(newValue) {\n            Object.defineProperty(promise, prop, {\n              value: newValue,\n              writable: true,\n              enumerable: true,\n            })\n          },\n          enumerable: true,\n          configurable: true,\n        })\n      } else {\n        ;(promise as any)[prop] = underlyingParams[prop]\n      }\n    }\n  })\n\n  return promise\n}\n\nfunction makeUntrackedExoticParams(underlyingParams: Params): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingParams)\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      ;(promise as any)[prop] = underlyingParams[prop]\n    }\n  })\n\n  return promise\n}\n\nfunction makeDynamicallyTrackedExoticParamsWithDevWarnings(\n  underlyingParams: Params,\n  store: WorkStore\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingParams)\n\n  const proxiedProperties = new Set<string>()\n  const unproxiedProperties: Array<string> = []\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n      unproxiedProperties.push(prop)\n    } else {\n      proxiedProperties.add(prop)\n      ;(promise as any)[prop] = underlyingParams[prop]\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n          // We are accessing a property that was proxied to the promise instance\n          proxiedProperties.has(prop)\n        ) {\n          const expression = describeStringPropertyAccess('params', prop)\n          warnForSyncAccess(store.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return ReflectAdapter.set(target, prop, value, receiver)\n    },\n    ownKeys(target) {\n      warnForEnumeration(store.route, unproxiedProperties)\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedParams.set(underlyingParams, proxiedPromise)\n  return proxiedPromise\n}\n\nconst noop = () => {}\n\nconst warnForSyncAccess = process.env.__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS\n  ? noop\n  : createDedupedByCallsiteServerErrorLoggerDev(function getSyncAccessMessage(\n      route: undefined | string,\n      expression: string\n    ) {\n      const prefix = route ? ` In route ${route} a ` : 'A '\n      return new Error(\n        `${prefix}param property was accessed directly with ${expression}. ` +\n          `\\`params\\` should be awaited before accessing its properties. ` +\n          `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n      )\n    })\n\nconst warnForEnumeration = process.env.__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS\n  ? noop\n  : createDedupedByCallsiteServerErrorLoggerDev(function getEnumerationMessage(\n      route: undefined | string,\n      missingProperties: Array<string>\n    ) {\n      const prefix = route ? ` In route ${route} ` : ''\n      if (missingProperties.length) {\n        const describedMissingProperties =\n          describeListOfPropertyNames(missingProperties)\n        return new Error(\n          `${prefix}params are being enumerated incompletely missing these properties: ${describedMissingProperties}. ` +\n            `\\`params\\` should be awaited before accessing its properties. ` +\n            `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n        )\n      } else {\n        return new Error(\n          `${prefix}params are being enumerated. ` +\n            `\\`params\\` should be awaited before accessing its properties. ` +\n            `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n        )\n      }\n    })\n\nfunction describeListOfPropertyNames(properties: Array<string>) {\n  switch (properties.length) {\n    case 0:\n      throw new InvariantError(\n        'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'\n      )\n    case 1:\n      return `\\`${properties[0]}\\``\n    case 2:\n      return `\\`${properties[0]}\\` and \\`${properties[1]}\\``\n    default: {\n      let description = ''\n      for (let i = 0; i < properties.length - 1; i++) {\n        description += `\\`${properties[i]}\\`, `\n      }\n      description += `, and \\`${properties[properties.length - 1]}\\``\n      return description\n    }\n  }\n}\n"],"names":["createPrerenderParamsForClientSegment","createPrerenderParamsFromClient","createRenderParamsFromClient","createServerParamsForMetadata","createServerParamsForRoute","createServerParamsForServerSegment","underlyingParams","workStore","createPrerenderParams","createRenderParams","isStaticGeneration","prerenderStore","workUnitAsyncStorage","getStore","type","fallbackParams","fallbackRouteParams","key","has","makeHangingPromise","renderSignal","makeResolvedReactPromise","hasSomeFallbackParams","workUnitStore","makeAbortingExoticParams","route","makeErroringExoticParams","InvariantError","makeUntrackedExoticParams","process","env","NODE_ENV","isPrefetchRequest","makeDynamicallyTrackedExoticParamsWithDevWarnings","CachedParams","WeakMap","cachedParams","get","promise","set","Object","keys","forEach","prop","wellKnownProperties","defineProperty","expression","describeStringPropertyAccess","error","Error","abortAndThrowOnSynchronousRequestDataAccess","newValue","value","writable","enumerable","configurable","augmentedUnderlying","Promise","resolve","postponeWithTracking","dynamicTracking","throwToInterruptStaticGeneration","store","proxiedProperties","Set","unproxiedProperties","push","add","proxiedPromise","Proxy","target","receiver","warnForSyncAccess","ReflectAdapter","delete","ownKeys","warnForEnumeration","Reflect","noop","__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS","createDedupedByCallsiteServerErrorLoggerDev","getSyncAccessMessage","prefix","getEnumerationMessage","missingProperties","length","describedMissingProperties","describeListOfPropertyNames","properties","description","i"],"mappings":"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"}