{"version":3,"sources":["../../../src/server/request/search-params.ts"],"sourcesContent":["import type { WorkStore } from '../app-render/work-async-storage.external'\n\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\nimport {\n  abortAndThrowOnSynchronousRequestDataAccess,\n  throwToInterruptStaticGeneration,\n  postponeWithTracking,\n  trackDynamicDataInDynamicRender,\n  annotateDynamicAccess,\n} from '../app-render/dynamic-rendering'\n\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStoreLegacy,\n  type PrerenderStorePPR,\n  type PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-loger'\nimport {\n  describeStringPropertyAccess,\n  describeHasCheckingStringProperty,\n  throwWithStaticGenerationBailoutErrorWithDynamicError,\n  wellKnownProperties,\n} from './utils'\n\nexport type SearchParams = { [key: string]: string | string[] | undefined }\n\n/**\n * In this version of Next.js the `params` prop passed to Layouts, Pages, and other Segments is a Promise.\n * However to facilitate migration to this new Promise type you can currently still access params directly on the Promise instance passed to these Segments.\n * The `UnsafeUnwrappedSearchParams` type is available if you need to temporarily access the underlying params without first awaiting or `use`ing the Promise.\n *\n * In a future version of Next.js the `params` prop will be a plain Promise and this type will be removed.\n *\n * Typically instances of `params` can be updated automatically to be treated as a Promise by a codemod published alongside this Next.js version however if you\n * have not yet run the codemod of the codemod cannot detect certain instances of `params` usage you should first try to refactor your code to await `params`.\n *\n * If refactoring is not possible but you still want to be able to access params directly without typescript errors you can cast the params Promise to this type\n *\n * ```tsx\n * type Props = { searchParams: Promise<{ foo: string }> }\n *\n * export default async function Page(props: Props) {\n *  const { searchParams } = (props.searchParams as unknown as UnsafeUnwrappedSearchParams<typeof props.searchParams>)\n *  return ...\n * }\n * ```\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedSearchParams<P> =\n  P extends Promise<infer U> ? Omit<U, 'then' | 'status' | 'value'> : never\n\nexport function createPrerenderSearchParamsFromClient(workStore: WorkStore) {\n  return createPrerenderSearchParams(workStore)\n}\n\nexport function createRenderSearchParamsFromClient(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore\n) {\n  return createRenderSearchParams(underlyingSearchParams, workStore)\n}\n\n// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component\nexport const createServerSearchParamsForMetadata =\n  createServerSearchParamsForServerPage\n\nexport function createServerSearchParamsForServerPage(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore\n): Promise<SearchParams> {\n  if (workStore.isStaticGeneration) {\n    return createPrerenderSearchParams(workStore)\n  } else {\n    return createRenderSearchParams(underlyingSearchParams, workStore)\n  }\n}\n\nexport function createPrerenderSearchParamsForClientPage(\n  workStore: WorkStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  }\n\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  if (prerenderStore && prerenderStore.type === 'prerender') {\n    // dynamicIO Prerender\n    // We're prerendering in a mode that aborts (dynamicIO) and should stall\n    // the promise to ensure the RSC side is considered dynamic\n    return makeHangingPromise(prerenderStore.renderSignal, '`searchParams`')\n  }\n  // We're prerendering in a mode that does not aborts. We resolve the promise without\n  // any tracking because we're just transporting a value from server to client where the tracking\n  // will be applied.\n  return Promise.resolve({})\n}\n\nfunction createPrerenderSearchParams(\n  workStore: WorkStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  }\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    if (workUnitStore.type === 'prerender') {\n      // We are in a dynamicIO (PPR or otherwise) prerender\n      return makeAbortingExoticSearchParams(workStore.route, workUnitStore)\n    } else if (\n      workUnitStore.type === 'prerender-legacy' ||\n      workUnitStore.type === 'prerender-ppr'\n    ) {\n      // We are in a legacy static generation and need to interrupt the prerender\n      // when search params are accessed.\n      return makeErroringExoticSearchParams(workStore, workUnitStore)\n    }\n  }\n  throw new InvariantError(\n    'createPrerenderSearchParams called without a prerenderStore in scope. This is a bug in Next.js'\n  )\n}\n\nfunction createRenderSearchParams(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  } else {\n    if (\n      process.env.NODE_ENV === 'development' &&\n      !workStore.isPrefetchRequest\n    ) {\n      return makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(\n        underlyingSearchParams,\n        workStore\n      )\n    } else {\n      return makeUntrackedExoticSearchParams(underlyingSearchParams, workStore)\n    }\n  }\n}\n\ninterface CacheLifetime {}\nconst CachedSearchParams = new WeakMap<CacheLifetime, Promise<SearchParams>>()\n\nfunction makeAbortingExoticSearchParams(\n  route: string,\n  prerenderStore: PrerenderStoreModern\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(prerenderStore)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const promise = makeHangingPromise<SearchParams>(\n    prerenderStore.renderSignal,\n    '`searchParams`'\n  )\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it.\n        // We know it isn't a dynamic access because it can only be something\n        // that was previously written to the promise and thus not an underlying searchParam value\n        return ReflectAdapter.get(target, prop, receiver)\n      }\n\n      switch (prop) {\n        case 'then': {\n          const expression =\n            '`await searchParams`, `searchParams.then`, or similar'\n          annotateDynamicAccess(expression, prerenderStore)\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n        case 'status': {\n          const expression =\n            '`use(searchParams)`, `searchParams.status`, or similar'\n          annotateDynamicAccess(expression, prerenderStore)\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n        // Object prototype\n        case 'hasOwnProperty':\n        case 'isPrototypeOf':\n        case 'propertyIsEnumerable':\n        case 'toString':\n        case 'valueOf':\n        case 'toLocaleString':\n\n        // Promise prototype\n        // fallthrough\n        case 'catch':\n        case 'finally':\n\n        // Common tested properties\n        // fallthrough\n        case 'toJSON':\n        case '$$typeof':\n        case '__esModule': {\n          // These properties cannot be shadowed because they need to be the\n          // true underlying value for Promises to work correctly at runtime\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n\n        default: {\n          if (typeof prop === 'string') {\n            const expression = describeStringPropertyAccess(\n              'searchParams',\n              prop\n            )\n            const error = createSyncSearchParamsError(route, expression)\n            abortAndThrowOnSynchronousRequestDataAccess(\n              route,\n              expression,\n              error,\n              prerenderStore\n            )\n          }\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n      }\n    },\n    has(target, prop) {\n      // We don't expect key checking to be used except for testing the existence of\n      // searchParams so we make all has tests trigger dynamic. this means that `promise.then`\n      // can resolve to the then function on the Promise prototype but 'then' in promise will assume\n      // you are testing whether the searchParams has a 'then' property.\n      if (typeof prop === 'string') {\n        const expression = describeHasCheckingStringProperty(\n          'searchParams',\n          prop\n        )\n        const error = createSyncSearchParamsError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      }\n      return ReflectAdapter.has(target, prop)\n    },\n    ownKeys() {\n      const expression =\n        '`{...searchParams}`, `Object.keys(searchParams)`, or similar'\n      const error = createSyncSearchParamsError(route, expression)\n      abortAndThrowOnSynchronousRequestDataAccess(\n        route,\n        expression,\n        error,\n        prerenderStore\n      )\n    },\n  })\n\n  CachedSearchParams.set(prerenderStore, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction makeErroringExoticSearchParams(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStoreLegacy | PrerenderStorePPR\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(workStore)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const underlyingSearchParams = {}\n  // For search params we don't construct a ReactPromise because we want to interrupt\n  // rendering on any property access that was not set from outside and so we only want\n  // to have properties like value and status if React sets them.\n  const promise = Promise.resolve(underlyingSearchParams)\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it.\n        // We know it isn't a dynamic access because it can only be something\n        // that was previously written to the promise and thus not an underlying searchParam value\n        return ReflectAdapter.get(target, prop, receiver)\n      }\n\n      switch (prop) {\n        // Object prototype\n        case 'hasOwnProperty':\n        case 'isPrototypeOf':\n        case 'propertyIsEnumerable':\n        case 'toString':\n        case 'valueOf':\n        case 'toLocaleString':\n\n        // Promise prototype\n        // fallthrough\n        case 'catch':\n        case 'finally':\n\n        // Common tested properties\n        // fallthrough\n        case 'toJSON':\n        case '$$typeof':\n        case '__esModule': {\n          // These properties cannot be shadowed because they need to be the\n          // true underlying value for Promises to work correctly at runtime\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n        case 'then': {\n          const expression =\n            '`await searchParams`, `searchParams.then`, or similar'\n          if (workStore.dynamicShouldError) {\n            throwWithStaticGenerationBailoutErrorWithDynamicError(\n              workStore.route,\n              expression\n            )\n          } else if (prerenderStore.type === 'prerender-ppr') {\n            // PPR Prerender (no dynamicIO)\n            postponeWithTracking(\n              workStore.route,\n              expression,\n              prerenderStore.dynamicTracking\n            )\n          } else {\n            // Legacy Prerender\n            throwToInterruptStaticGeneration(\n              expression,\n              workStore,\n              prerenderStore\n            )\n          }\n          return\n        }\n        case 'status': {\n          const expression =\n            '`use(searchParams)`, `searchParams.status`, or similar'\n          if (workStore.dynamicShouldError) {\n            throwWithStaticGenerationBailoutErrorWithDynamicError(\n              workStore.route,\n              expression\n            )\n          } else if (prerenderStore.type === 'prerender-ppr') {\n            // PPR Prerender (no dynamicIO)\n            postponeWithTracking(\n              workStore.route,\n              expression,\n              prerenderStore.dynamicTracking\n            )\n          } else {\n            // Legacy Prerender\n            throwToInterruptStaticGeneration(\n              expression,\n              workStore,\n              prerenderStore\n            )\n          }\n          return\n        }\n        default: {\n          if (typeof prop === 'string') {\n            const expression = describeStringPropertyAccess(\n              'searchParams',\n              prop\n            )\n            if (workStore.dynamicShouldError) {\n              throwWithStaticGenerationBailoutErrorWithDynamicError(\n                workStore.route,\n                expression\n              )\n            } else if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no dynamicIO)\n              postponeWithTracking(\n                workStore.route,\n                expression,\n                prerenderStore.dynamicTracking\n              )\n            } else {\n              // Legacy Prerender\n              throwToInterruptStaticGeneration(\n                expression,\n                workStore,\n                prerenderStore\n              )\n            }\n          }\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n      }\n    },\n    has(target, prop) {\n      // We don't expect key checking to be used except for testing the existence of\n      // searchParams so we make all has tests trigger dynamic. this means that `promise.then`\n      // can resolve to the then function on the Promise prototype but 'then' in promise will assume\n      // you are testing whether the searchParams has a 'then' property.\n      if (typeof prop === 'string') {\n        const expression = describeHasCheckingStringProperty(\n          'searchParams',\n          prop\n        )\n        if (workStore.dynamicShouldError) {\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            workStore.route,\n            expression\n          )\n        } else if (prerenderStore.type === 'prerender-ppr') {\n          // PPR Prerender (no dynamicIO)\n          postponeWithTracking(\n            workStore.route,\n            expression,\n            prerenderStore.dynamicTracking\n          )\n        } else {\n          // Legacy Prerender\n          throwToInterruptStaticGeneration(\n            expression,\n            workStore,\n            prerenderStore\n          )\n        }\n        return false\n      }\n      return ReflectAdapter.has(target, prop)\n    },\n    ownKeys() {\n      const expression =\n        '`{...searchParams}`, `Object.keys(searchParams)`, or similar'\n      if (workStore.dynamicShouldError) {\n        throwWithStaticGenerationBailoutErrorWithDynamicError(\n          workStore.route,\n          expression\n        )\n      } else if (prerenderStore.type === 'prerender-ppr') {\n        // PPR Prerender (no dynamicIO)\n        postponeWithTracking(\n          workStore.route,\n          expression,\n          prerenderStore.dynamicTracking\n        )\n      } else {\n        // Legacy Prerender\n        throwToInterruptStaticGeneration(expression, workStore, prerenderStore)\n      }\n    },\n  })\n\n  CachedSearchParams.set(workStore, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction makeUntrackedExoticSearchParams(\n  underlyingSearchParams: SearchParams,\n  store: WorkStore\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  // We don't use makeResolvedReactPromise here because searchParams\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingSearchParams)\n  CachedSearchParams.set(underlyingSearchParams, promise)\n\n  Object.keys(underlyingSearchParams).forEach((prop) => {\n    switch (prop) {\n      // Object prototype\n      case 'hasOwnProperty':\n      case 'isPrototypeOf':\n      case 'propertyIsEnumerable':\n      case 'toString':\n      case 'valueOf':\n      case 'toLocaleString':\n\n      // Promise prototype\n      // fallthrough\n      case 'then':\n      case 'catch':\n      case 'finally':\n\n      // React Promise extension\n      // fallthrough\n      case 'status':\n\n      // Common tested properties\n      // fallthrough\n      case 'toJSON':\n      case '$$typeof':\n      case '__esModule': {\n        // These properties cannot be shadowed because they need to be the\n        // true underlying value for Promises to work correctly at runtime\n        break\n      }\n      default: {\n        Object.defineProperty(promise, prop, {\n          get() {\n            const workUnitStore = workUnitAsyncStorage.getStore()\n            trackDynamicDataInDynamicRender(store, workUnitStore)\n            return underlyingSearchParams[prop]\n          },\n          set(value) {\n            Object.defineProperty(promise, prop, {\n              value,\n              writable: true,\n              enumerable: true,\n            })\n          },\n          enumerable: true,\n          configurable: true,\n        })\n      }\n    }\n  })\n\n  return promise\n}\n\nfunction makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(\n  underlyingSearchParams: SearchParams,\n  store: WorkStore\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const proxiedProperties = new Set<string>()\n  const unproxiedProperties: Array<string> = []\n\n  // We have an unfortunate sequence of events that requires this initialization logic. We want to instrument the underlying\n  // searchParams object to detect if you are accessing values in dev. This is used for warnings and for things like the static prerender\n  // indicator. However when we pass this proxy to our Promise.resolve() below the VM checks if the resolved value is a promise by looking\n  // at the `.then` property. To our dynamic tracking logic this is indistinguishable from a `then` searchParam and so we would normally trigger\n  // dynamic tracking. However we know that this .then is not real dynamic access, it's just how thenables resolve in sequence. So we introduce\n  // this initialization concept so we omit the dynamic check until after we've constructed our resolved promise.\n  let promiseInitialized = false\n  const proxiedUnderlying = new Proxy(underlyingSearchParams, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string' && promiseInitialized) {\n        if (store.dynamicShouldError) {\n          const expression = describeStringPropertyAccess('searchParams', prop)\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            store.route,\n            expression\n          )\n        }\n        const workUnitStore = workUnitAsyncStorage.getStore()\n        trackDynamicDataInDynamicRender(store, workUnitStore)\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (store.dynamicShouldError) {\n          const expression = describeHasCheckingStringProperty(\n            'searchParams',\n            prop\n          )\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            store.route,\n            expression\n          )\n        }\n      }\n      return Reflect.has(target, prop)\n    },\n    ownKeys(target) {\n      if (store.dynamicShouldError) {\n        const expression =\n          '`{...searchParams}`, `Object.keys(searchParams)`, or similar'\n        throwWithStaticGenerationBailoutErrorWithDynamicError(\n          store.route,\n          expression\n        )\n      }\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  // We don't use makeResolvedReactPromise here because searchParams\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(proxiedUnderlying)\n  promise.then(() => {\n    promiseInitialized = true\n  })\n\n  Object.keys(underlyingSearchParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n      unproxiedProperties.push(prop)\n    } else {\n      proxiedProperties.add(prop)\n      Object.defineProperty(promise, prop, {\n        get() {\n          return proxiedUnderlying[prop]\n        },\n        set(newValue) {\n          Object.defineProperty(promise, prop, {\n            value: newValue,\n            writable: true,\n            enumerable: true,\n          })\n        },\n        enumerable: true,\n        configurable: true,\n      })\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeStringPropertyAccess('searchParams', prop)\n          warnForSyncAccess(store.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return Reflect.set(target, prop, value, receiver)\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeHasCheckingStringProperty(\n            'searchParams',\n            prop\n          )\n          warnForSyncAccess(store.route, expression)\n        }\n      }\n      return Reflect.has(target, prop)\n    },\n    ownKeys(target) {\n      warnForEnumeration(store.route, unproxiedProperties)\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedSearchParams.set(underlyingSearchParams, proxiedPromise)\n  return proxiedPromise\n}\n\nconst noop = () => {}\n\nconst warnForSyncAccess = process.env.__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS\n  ? noop\n  : createDedupedByCallsiteServerErrorLoggerDev(function getSyncAccessMessage(\n      route: undefined | string,\n      expression: string\n    ) {\n      const prefix = route ? ` In route ${route} a ` : 'A '\n      return new Error(\n        `${prefix}searchParam property was accessed directly with ${expression}. ` +\n          `\\`searchParams\\` should be awaited before accessing properties. ` +\n          `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n      )\n    })\n\nconst warnForEnumeration = process.env.__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS\n  ? noop\n  : createDedupedByCallsiteServerErrorLoggerDev(function getEnumerationMessage(\n      route: undefined | string,\n      missingProperties: Array<string>\n    ) {\n      const prefix = route ? ` In route ${route} ` : ''\n      if (missingProperties.length) {\n        const describedMissingProperties =\n          describeListOfPropertyNames(missingProperties)\n        return new Error(\n          `${prefix}searchParams are being enumerated incompletely missing these properties: ${describedMissingProperties}. ` +\n            `\\`searchParams\\` should be awaited before accessing its properties. ` +\n            `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n        )\n      } else {\n        return new Error(\n          `${prefix}searchParams are being enumerated. ` +\n            `\\`searchParams\\` should be awaited before accessing its properties. ` +\n            `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n        )\n      }\n    })\n\nfunction describeListOfPropertyNames(properties: Array<string>) {\n  switch (properties.length) {\n    case 0:\n      throw new InvariantError(\n        'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'\n      )\n    case 1:\n      return `\\`${properties[0]}\\``\n    case 2:\n      return `\\`${properties[0]}\\` and \\`${properties[1]}\\``\n    default: {\n      let description = ''\n      for (let i = 0; i < properties.length - 1; i++) {\n        description += `\\`${properties[i]}\\`, `\n      }\n      description += `, and \\`${properties[properties.length - 1]}\\``\n      return description\n    }\n  }\n}\n\nfunction createSyncSearchParamsError(route: string, expression: string) {\n  return new Error(\n    `Route \"${route}\" used ${expression}. \\`searchParams\\` is now a Promise and should be \\`awaited\\` before accessing search param values. See more info here: https://nextjs.org/docs/messages/next-prerender-sync-params`\n  )\n}\n"],"names":["createPrerenderSearchParamsForClientPage","createPrerenderSearchParamsFromClient","createRenderSearchParamsFromClient","createServerSearchParamsForMetadata","createServerSearchParamsForServerPage","workStore","createPrerenderSearchParams","underlyingSearchParams","createRenderSearchParams","isStaticGeneration","forceStatic","Promise","resolve","prerenderStore","workUnitAsyncStorage","getStore","type","makeHangingPromise","renderSignal","workUnitStore","makeAbortingExoticSearchParams","route","makeErroringExoticSearchParams","InvariantError","process","env","NODE_ENV","isPrefetchRequest","makeDynamicallyTrackedExoticSearchParamsWithDevWarnings","makeUntrackedExoticSearchParams","CachedSearchParams","WeakMap","cachedSearchParams","get","promise","proxiedPromise","Proxy","target","prop","receiver","Object","hasOwn","ReflectAdapter","expression","annotateDynamicAccess","describeStringPropertyAccess","error","createSyncSearchParamsError","abortAndThrowOnSynchronousRequestDataAccess","has","describeHasCheckingStringProperty","ownKeys","set","dynamicShouldError","throwWithStaticGenerationBailoutErrorWithDynamicError","postponeWithTracking","dynamicTracking","throwToInterruptStaticGeneration","store","keys","forEach","defineProperty","trackDynamicDataInDynamicRender","value","writable","enumerable","configurable","proxiedProperties","Set","unproxiedProperties","promiseInitialized","proxiedUnderlying","Reflect","then","wellKnownProperties","push","add","newValue","warnForSyncAccess","delete","warnForEnumeration","noop","__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS","createDedupedByCallsiteServerErrorLoggerDev","getSyncAccessMessage","prefix","Error","getEnumerationMessage","missingProperties","length","describedMissingProperties","describeListOfPropertyNames","properties","description","i"],"mappings":"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"}