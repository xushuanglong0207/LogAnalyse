{"version":3,"sources":["../../../../../../src/client/components/react-dev-overlay/internal/helpers/stack-frame.ts"],"sourcesContent":["import type { StackFrame } from 'next/dist/compiled/stacktrace-parser'\nimport type { OriginalStackFrameResponse } from '../../server/shared'\n\nexport interface OriginalStackFrame extends OriginalStackFrameResponse {\n  error: boolean\n  reason: string | null\n  external: boolean\n  expanded: boolean\n  sourceStackFrame: StackFrame\n}\n\nfunction getOriginalStackFrame(\n  source: StackFrame,\n  type: 'server' | 'edge-server' | null,\n  isAppDir: boolean,\n  errorMessage: string\n): Promise<OriginalStackFrame> {\n  async function _getOriginalStackFrame(): Promise<OriginalStackFrame> {\n    const params = new URLSearchParams()\n    params.append('isServer', String(type === 'server'))\n    params.append('isEdgeServer', String(type === 'edge-server'))\n    params.append('isAppDirectory', String(isAppDir))\n    params.append('errorMessage', errorMessage)\n    for (const key in source) {\n      params.append(key, ((source as any)[key] ?? '').toString())\n    }\n\n    const controller = new AbortController()\n    const tm = setTimeout(() => controller.abort(), 3000)\n    const res = await self\n      .fetch(\n        `${\n          process.env.__NEXT_ROUTER_BASEPATH || ''\n        }/__nextjs_original-stack-frame?${params.toString()}`,\n        { signal: controller.signal }\n      )\n      .finally(() => {\n        clearTimeout(tm)\n      })\n    if (!res.ok || res.status === 204) {\n      return Promise.reject(new Error(await res.text()))\n    }\n\n    const body: OriginalStackFrameResponse = await res.json()\n    return {\n      error: false,\n      reason: null,\n      external: false,\n      expanded: !Boolean(\n        /* collapsed */\n        (source.file?.includes('node_modules') ||\n          body.originalStackFrame?.file?.includes('node_modules') ||\n          body.originalStackFrame?.file?.startsWith('[turbopack]/')) ??\n          true\n      ),\n      sourceStackFrame: source,\n      originalStackFrame: body.originalStackFrame,\n      originalCodeFrame: body.originalCodeFrame || null,\n      sourcePackage: body.sourcePackage,\n    }\n  }\n\n  if (\n    source.file === '<anonymous>' ||\n    source.file === 'file://' ||\n    source.file?.match(/^node:/) ||\n    source.file?.match(/https?:\\/\\//)\n  ) {\n    return Promise.resolve({\n      error: false,\n      reason: null,\n      external: true,\n      expanded: false,\n      sourceStackFrame: source,\n      originalStackFrame: null,\n      originalCodeFrame: null,\n      sourcePackage: null,\n    })\n  }\n\n  return _getOriginalStackFrame().catch((err: Error) => ({\n    error: true,\n    reason: err?.message ?? err?.toString() ?? 'Unknown Error',\n    external: false,\n    expanded: false,\n    sourceStackFrame: source,\n    originalStackFrame: null,\n    originalCodeFrame: null,\n    sourcePackage: null,\n  }))\n}\n\nexport function getOriginalStackFrames(\n  frames: StackFrame[],\n  type: 'server' | 'edge-server' | null,\n  isAppDir: boolean,\n  errorMessage: string\n) {\n  return Promise.all(\n    frames.map((frame) =>\n      getOriginalStackFrame(frame, type, isAppDir, errorMessage)\n    )\n  )\n}\n\nconst webpackRegExes = [\n  /^(rsc:\\/\\/React\\/[^/]+\\/)?webpack-internal:\\/\\/\\/(\\.)?(\\((\\w+)\\))?/,\n  /^(webpack:\\/\\/\\/(\\.)?|webpack:\\/\\/(_N_E\\/)?)(\\((\\w+)\\))?/,\n]\n\nconst replacementRegExes = [\n  /^(rsc:\\/\\/React\\/[^/]+\\/)/,\n  /^webpack-internal:\\/\\/\\/(\\.)?(\\((\\w+)\\))?/,\n  /^(webpack:\\/\\/\\/(\\.)?|webpack:\\/\\/(_N_E\\/)?)(\\((\\w+)\\))?/,\n  /\\?\\d+$/, // React's fakeFunctionIdx query param\n]\n\nfunction isWebpackBundled(file: string) {\n  return webpackRegExes.some((regEx) => regEx.test(file))\n}\n\n/**\n * Format the webpack internal id to original file path\n * webpack-internal:///./src/hello.tsx => ./src/hello.tsx\n * rsc://React/Server/webpack-internal:///(rsc)/./src/hello.tsx?42 => ./src/hello.tsx\n * webpack://_N_E/./src/hello.tsx => ./src/hello.tsx\n * webpack://./src/hello.tsx => ./src/hello.tsx\n * webpack:///./src/hello.tsx => ./src/hello.tsx\n *\n * <anonymous> => ''\n */\nfunction formatFrameSourceFile(file: string) {\n  if (file === '<anonymous>') return ''\n\n  for (const regex of replacementRegExes) {\n    file = file.replace(regex, '')\n  }\n\n  return file\n}\n\nexport function getFrameSource(frame: StackFrame): string {\n  if (!frame.file) return ''\n\n  const isWebpackFrame = isWebpackBundled(frame.file)\n\n  let str = ''\n  // Skip URL parsing for webpack internal file paths.\n  if (isWebpackFrame) {\n    str = formatFrameSourceFile(frame.file)\n  } else {\n    try {\n      const u = new URL(frame.file)\n\n      let parsedPath = ''\n      // Strip the origin for same-origin scripts.\n      if (globalThis.location?.origin !== u.origin) {\n        // URLs can be valid without an `origin`, so long as they have a\n        // `protocol`. However, `origin` is preferred.\n        if (u.origin === 'null') {\n          parsedPath += u.protocol\n        } else {\n          parsedPath += u.origin\n        }\n      }\n\n      // Strip query string information as it's typically too verbose to be\n      // meaningful.\n      parsedPath += u.pathname\n      str = formatFrameSourceFile(parsedPath)\n    } catch {\n      str = formatFrameSourceFile(frame.file)\n    }\n  }\n\n  if (!isWebpackBundled(frame.file) && frame.lineNumber != null) {\n    if (frame.column != null) {\n      str += ` (${frame.lineNumber}:${frame.column})`\n    } else {\n      str += ` (${frame.lineNumber})`\n    }\n  }\n  return str\n}\n"],"names":["getOriginalStackFrame","source","type","isAppDir","errorMessage","_getOriginalStackFrame","body","params","URLSearchParams","append","String","key","toString","controller","AbortController","tm","setTimeout","abort","res","self","fetch","process","env","__NEXT_ROUTER_BASEPATH","signal","finally","clearTimeout","ok","status","Promise","reject","Error","text","json","error","reason","external","expanded","Boolean","file","includes","originalStackFrame","startsWith","sourceStackFrame","originalCodeFrame","sourcePackage","match","resolve","catch","err","message","getOriginalStackFrames","frames","all","map","frame","webpackRegExes","replacementRegExes","isWebpackBundled","some","regEx","test","formatFrameSourceFile","regex","replace","getFrameSource","isWebpackFrame","str","globalThis","u","URL","parsedPath","location","origin","protocol","pathname","lineNumber","column"],"mappings":"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"}