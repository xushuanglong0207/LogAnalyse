{"version":3,"sources":["../../../src/server/request/params.ts"],"sourcesContent":["import type { WorkStore } from '../app-render/work-async-storage.external'\nimport type { FallbackRouteParams } from './fallback-params'\n\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\nimport {\n  abortAndThrowOnSynchronousRequestDataAccess,\n  throwToInterruptStaticGeneration,\n  postponeWithTracking,\n} from '../app-render/dynamic-rendering'\n\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStorePPR,\n  type PrerenderStoreLegacy,\n  type PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport {\n  makeResolvedReactPromise,\n  describeStringPropertyAccess,\n  wellKnownProperties,\n} from './utils'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-loger'\n\nexport type Params = Record<string, string | Array<string> | undefined>\n\n/**\n * In this version of Next.js the `params` prop passed to Layouts, Pages, and other Segments is a Promise.\n * However to facilitate migration to this new Promise type you can currently still access params directly on the Promise instance passed to these Segments.\n * The `UnsafeUnwrappedParams` type is available if you need to temporarily access the underlying params without first awaiting or `use`ing the Promise.\n *\n * In a future version of Next.js the `params` prop will be a plain Promise and this type will be removed.\n *\n * Typically instances of `params` can be updated automatically to be treated as a Promise by a codemod published alongside this Next.js version however if you\n * have not yet run the codemod of the codemod cannot detect certain instances of `params` usage you should first try to refactor your code to await `params`.\n *\n * If refactoring is not possible but you still want to be able to access params directly without typescript errors you can cast the params Promise to this type\n *\n * ```tsx\n * type Props = { params: Promise<{ id: string }>}\n *\n * export default async function Layout(props: Props) {\n *  const directParams = (props.params as unknown as UnsafeUnwrappedParams<typeof props.params>)\n *  return ...\n * }\n * ```\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedParams<P> =\n  P extends Promise<infer U> ? Omit<U, 'then' | 'status' | 'value'> : never\n\nexport function createPrerenderParamsFromClient(\n  underlyingParams: Params,\n  workStore: WorkStore\n) {\n  return createPrerenderParams(underlyingParams, workStore)\n}\n\nexport function createRenderParamsFromClient(\n  underlyingParams: Params,\n  workStore: WorkStore\n) {\n  return createRenderParams(underlyingParams, workStore)\n}\n\n// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component\nexport type CreateServerParamsForMetadata = typeof createServerParamsForMetadata\nexport const createServerParamsForMetadata = createServerParamsForServerSegment\n\n// routes always runs in RSC context so it is equivalent to a Server Page Component\nexport function createServerParamsForRoute(\n  underlyingParams: Params,\n  workStore: WorkStore\n) {\n  if (workStore.isStaticGeneration) {\n    return createPrerenderParams(underlyingParams, workStore)\n  } else {\n    return createRenderParams(underlyingParams, workStore)\n  }\n}\n\nexport function createServerParamsForServerSegment(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  if (workStore.isStaticGeneration) {\n    return createPrerenderParams(underlyingParams, workStore)\n  } else {\n    return createRenderParams(underlyingParams, workStore)\n  }\n}\n\nexport function createPrerenderParamsForClientSegment(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  if (prerenderStore && prerenderStore.type === 'prerender') {\n    const fallbackParams = workStore.fallbackRouteParams\n    if (fallbackParams) {\n      for (let key in underlyingParams) {\n        if (fallbackParams.has(key)) {\n          // This params object has one of more fallback params so we need to consider\n          // the awaiting of this params object \"dynamic\". Since we are in dynamicIO mode\n          // we encode this as a promise that never resolves\n          return makeHangingPromise(prerenderStore.renderSignal, '`params`')\n        }\n      }\n    }\n  }\n  // We're prerendering in a mode that does not abort. We resolve the promise without\n  // any tracking because we're just transporting a value from server to client where the tracking\n  // will be applied.\n  return makeResolvedReactPromise(underlyingParams)\n}\n\nfunction createPrerenderParams(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const fallbackParams = workStore.fallbackRouteParams\n  if (fallbackParams) {\n    let hasSomeFallbackParams = false\n    for (const key in underlyingParams) {\n      if (fallbackParams.has(key)) {\n        hasSomeFallbackParams = true\n        break\n      }\n    }\n\n    if (hasSomeFallbackParams) {\n      // params need to be treated as dynamic because we have at least one fallback param\n      const workUnitStore = workUnitAsyncStorage.getStore()\n      if (workUnitStore) {\n        if (workUnitStore.type === 'prerender') {\n          // We are in a dynamicIO (PPR or otherwise) prerender\n          return makeAbortingExoticParams(\n            underlyingParams,\n            workStore.route,\n            workUnitStore\n          )\n        } else if (\n          workUnitStore.type === 'prerender-legacy' ||\n          workUnitStore.type === 'prerender-ppr'\n        )\n          // We aren't in a dynamicIO prerender but we do have fallback params at this\n          // level so we need to make an erroring exotic params object which will postpone\n          // if you access the fallback params\n          return makeErroringExoticParams(\n            underlyingParams,\n            fallbackParams,\n            workStore,\n            workUnitStore\n          )\n      }\n      throw new InvariantError(\n        'createPrerenderParams called without a prerenderStore in scope. This is a bug in Next.js'\n      )\n    }\n  }\n\n  // We don't have any fallback params so we have an entirely static safe params object\n  return makeUntrackedExoticParams(underlyingParams)\n}\n\nfunction createRenderParams(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  if (process.env.NODE_ENV === 'development' && !workStore.isPrefetchRequest) {\n    return makeDynamicallyTrackedExoticParamsWithDevWarnings(\n      underlyingParams,\n      workStore\n    )\n  } else {\n    return makeUntrackedExoticParams(underlyingParams)\n  }\n}\n\ninterface CacheLifetime {}\nconst CachedParams = new WeakMap<CacheLifetime, Promise<Params>>()\n\nfunction makeAbortingExoticParams(\n  underlyingParams: Params,\n  route: string,\n  prerenderStore: PrerenderStoreModern\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const promise = makeHangingPromise<Params>(\n    prerenderStore.renderSignal,\n    '`params`'\n  )\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      Object.defineProperty(promise, prop, {\n        get() {\n          const expression = describeStringPropertyAccess('params', prop)\n          const error = new Error(\n            `Route \"${route}\" used ${expression}. \\`params\\` is now a Promise and should be \\`awaited\\` before accessing param values. See more info here: https://nextjs.org/docs/messages/next-prerender-sync-params`\n          )\n          abortAndThrowOnSynchronousRequestDataAccess(\n            route,\n            expression,\n            error,\n            prerenderStore\n          )\n        },\n        set(newValue) {\n          Object.defineProperty(promise, prop, {\n            value: newValue,\n            writable: true,\n            enumerable: true,\n          })\n        },\n        enumerable: true,\n        configurable: true,\n      })\n    }\n  })\n\n  return promise\n}\n\nfunction makeErroringExoticParams(\n  underlyingParams: Params,\n  fallbackParams: FallbackRouteParams,\n  workStore: WorkStore,\n  prerenderStore: PrerenderStorePPR | PrerenderStoreLegacy\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const augmentedUnderlying = { ...underlyingParams }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(augmentedUnderlying)\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      if (fallbackParams.has(prop)) {\n        Object.defineProperty(augmentedUnderlying, prop, {\n          get() {\n            const expression = describeStringPropertyAccess('params', prop)\n            // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n            // for params is only dynamic when we're generating a fallback shell\n            // and even when `dynamic = \"error\"` we still support generating dynamic\n            // fallback shells\n            // TODO remove this comment when dynamicIO is the default since there\n            // will be no `dynamic = \"error\"`\n            if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no dynamicIO)\n              postponeWithTracking(\n                workStore.route,\n                expression,\n                prerenderStore.dynamicTracking\n              )\n            } else {\n              // Legacy Prerender\n              throwToInterruptStaticGeneration(\n                expression,\n                workStore,\n                prerenderStore\n              )\n            }\n          },\n          enumerable: true,\n        })\n        Object.defineProperty(promise, prop, {\n          get() {\n            const expression = describeStringPropertyAccess('params', prop)\n            // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n            // for params is only dynamic when we're generating a fallback shell\n            // and even when `dynamic = \"error\"` we still support generating dynamic\n            // fallback shells\n            // TODO remove this comment when dynamicIO is the default since there\n            // will be no `dynamic = \"error\"`\n            if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no dynamicIO)\n              postponeWithTracking(\n                workStore.route,\n                expression,\n                prerenderStore.dynamicTracking\n              )\n            } else {\n              // Legacy Prerender\n              throwToInterruptStaticGeneration(\n                expression,\n                workStore,\n                prerenderStore\n              )\n            }\n          },\n          set(newValue) {\n            Object.defineProperty(promise, prop, {\n              value: newValue,\n              writable: true,\n              enumerable: true,\n            })\n          },\n          enumerable: true,\n          configurable: true,\n        })\n      } else {\n        ;(promise as any)[prop] = underlyingParams[prop]\n      }\n    }\n  })\n\n  return promise\n}\n\nfunction makeUntrackedExoticParams(underlyingParams: Params): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingParams)\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      ;(promise as any)[prop] = underlyingParams[prop]\n    }\n  })\n\n  return promise\n}\n\nfunction makeDynamicallyTrackedExoticParamsWithDevWarnings(\n  underlyingParams: Params,\n  store: WorkStore\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingParams)\n\n  const proxiedProperties = new Set<string>()\n  const unproxiedProperties: Array<string> = []\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n      unproxiedProperties.push(prop)\n    } else {\n      proxiedProperties.add(prop)\n      ;(promise as any)[prop] = underlyingParams[prop]\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n          // We are accessing a property that was proxied to the promise instance\n          proxiedProperties.has(prop)\n        ) {\n          const expression = describeStringPropertyAccess('params', prop)\n          warnForSyncAccess(store.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return ReflectAdapter.set(target, prop, value, receiver)\n    },\n    ownKeys(target) {\n      warnForEnumeration(store.route, unproxiedProperties)\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedParams.set(underlyingParams, proxiedPromise)\n  return proxiedPromise\n}\n\nconst noop = () => {}\n\nconst warnForSyncAccess = process.env.__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS\n  ? noop\n  : createDedupedByCallsiteServerErrorLoggerDev(function getSyncAccessMessage(\n      route: undefined | string,\n      expression: string\n    ) {\n      const prefix = route ? ` In route ${route} a ` : 'A '\n      return new Error(\n        `${prefix}param property was accessed directly with ${expression}. ` +\n          `\\`params\\` should be awaited before accessing its properties. ` +\n          `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n      )\n    })\n\nconst warnForEnumeration = process.env.__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS\n  ? noop\n  : createDedupedByCallsiteServerErrorLoggerDev(function getEnumerationMessage(\n      route: undefined | string,\n      missingProperties: Array<string>\n    ) {\n      const prefix = route ? ` In route ${route} ` : ''\n      if (missingProperties.length) {\n        const describedMissingProperties =\n          describeListOfPropertyNames(missingProperties)\n        return new Error(\n          `${prefix}params are being enumerated incompletely missing these properties: ${describedMissingProperties}. ` +\n            `\\`params\\` should be awaited before accessing its properties. ` +\n            `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n        )\n      } else {\n        return new Error(\n          `${prefix}params are being enumerated. ` +\n            `\\`params\\` should be awaited before accessing its properties. ` +\n            `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n        )\n      }\n    })\n\nfunction describeListOfPropertyNames(properties: Array<string>) {\n  switch (properties.length) {\n    case 0:\n      throw new InvariantError(\n        'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'\n      )\n    case 1:\n      return `\\`${properties[0]}\\``\n    case 2:\n      return `\\`${properties[0]}\\` and \\`${properties[1]}\\``\n    default: {\n      let description = ''\n      for (let i = 0; i < properties.length - 1; i++) {\n        description += `\\`${properties[i]}\\`, `\n      }\n      description += `, and \\`${properties[properties.length - 1]}\\``\n      return description\n    }\n  }\n}\n"],"names":["ReflectAdapter","abortAndThrowOnSynchronousRequestDataAccess","throwToInterruptStaticGeneration","postponeWithTracking","workUnitAsyncStorage","InvariantError","makeResolvedReactPromise","describeStringPropertyAccess","wellKnownProperties","makeHangingPromise","createDedupedByCallsiteServerErrorLoggerDev","createPrerenderParamsFromClient","underlyingParams","workStore","createPrerenderParams","createRenderParamsFromClient","createRenderParams","createServerParamsForMetadata","createServerParamsForServerSegment","createServerParamsForRoute","isStaticGeneration","createPrerenderParamsForClientSegment","prerenderStore","getStore","type","fallbackParams","fallbackRouteParams","key","has","renderSignal","hasSomeFallbackParams","workUnitStore","makeAbortingExoticParams","route","makeErroringExoticParams","makeUntrackedExoticParams","process","env","NODE_ENV","isPrefetchRequest","makeDynamicallyTrackedExoticParamsWithDevWarnings","CachedParams","WeakMap","cachedParams","get","promise","set","Object","keys","forEach","prop","defineProperty","expression","error","Error","newValue","value","writable","enumerable","configurable","augmentedUnderlying","Promise","resolve","dynamicTracking","store","proxiedProperties","Set","unproxiedProperties","push","add","proxiedPromise","Proxy","target","receiver","warnForSyncAccess","delete","ownKeys","warnForEnumeration","Reflect","noop","__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS","getSyncAccessMessage","prefix","getEnumerationMessage","missingProperties","length","describedMissingProperties","describeListOfPropertyNames","properties","description","i"],"mappings":"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"}